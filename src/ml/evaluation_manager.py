import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
from scipy import linalg
import os


class EvaluationManager:
    """
    Performs various evaluations on the reservoir computing system.
    """
    
    def __init__(self, original_data, generated_data, generated_states=None, Win=None, A=None, Wout=None):
        """
        Initialize the evaluation manager.
        
        Args:
            original_data: Original data from the system being modeled
            generated_data: Data generated by the autonomous reservoir system
            generated_states: Reservoir states during autonomous generation
            Win: Input matrix
            A: Reservoir matrix
            Wout: Output weights
        """
        self.original_data = original_data
        self.generated_data = generated_data
        self.generated_states = generated_states
        self.Win = Win
        self.A = A
        self.Wout = Wout
        
    def evaluate_short_term(self, length=None, plot=True, save_dir=None):
        """
        Evaluate short-term prediction accuracy.
        
        Args:
            length: Number of time steps to use for comparison
            plot: Whether to create plots
            save_dir: Directory to save plots
            
        Returns:
            Dictionary of metrics
        """
        if length is None:
            length = min(1000, len(self.generated_data))
        
        # Ensure we don't exceed the data length
        length = min(length, len(self.original_data), len(self.generated_data))
        
        # Calculate MSE for each dimension
        errors = self.original_data[:length] - self.generated_data[:length]
        mse_per_dim = np.mean(errors**2, axis=0)
        mse_total = np.mean(mse_per_dim)
        
        # Calculate normalized RMSE
        original_std = np.std(self.original_data[:length], axis=0)
        nrmse_per_dim = np.sqrt(mse_per_dim) / original_std
        nrmse_total = np.mean(nrmse_per_dim)
        
        # Create plots if requested
        if plot:
            self._plot_short_term_prediction(length, save_dir)
        
        return {
            'mse_per_dim': mse_per_dim,
            'mse_total': mse_total,
            'nrmse_per_dim': nrmse_per_dim,
            'nrmse_total': nrmse_total
        }
    
    def evaluate_climate(self, plot=True, save_dir=None):
        """
        Evaluate climate statistics and attractors.
        
        Args:
            plot: Whether to create plots
            save_dir: Directory to save plots
            
        Returns:
            Dictionary of metrics
        """
        # Calculate basic statistics
        orig_mean = np.mean(self.original_data, axis=0)
        gen_mean = np.mean(self.generated_data, axis=0)
        
        orig_std = np.std(self.original_data, axis=0)
        gen_std = np.std(self.generated_data, axis=0)
        
        # Calculate histogram distances
        hist_distances = self._calculate_histogram_distances()
        
        # Calculate power spectra distances
        spectra_distances = self._calculate_power_spectra_distances()
        
        # Create plots if requested
        if plot:
            self._plot_attractors(save_dir)
            self._plot_return_maps(save_dir)
            self._plot_power_spectra(save_dir)
        
        return {
            'mean_diff': gen_mean - orig_mean,
            'std_diff': gen_std - orig_std,
            'hist_distances': hist_distances,
            'spectra_distances': spectra_distances
        }
    
    def evaluate_lyapunov(self, num_exponents=None, transient_steps=1000, orthonormalization_interval=10, 
                           plot=True, save_dir=None):
        """
        Calculate Lyapunov exponents of the autonomous system.
        
        Args:
            num_exponents: Number of Lyapunov exponents to calculate
            transient_steps: Steps to run before starting averaging
            orthonormalization_interval: Steps between QR decompositions
            plot: Whether to create plots
            save_dir: Directory to save plots
            
        Returns:
            Array of calculated Lyapunov exponents
        """
        if self.generated_states is None or self.Win is None or self.A is None or self.Wout is None:
            raise ValueError("Lyapunov calculation requires generated states and all system matrices")
        
        # Default to system dimension if num_exponents not specified
        if num_exponents is None:
            num_exponents = min(10, self.original_data.shape[1])
        
        # Get dimensions
        D = self.original_data.shape[1]  # Data dimension
        Dr = self.Win.shape[0]  # Reservoir size
        
        # Ensure num_exponents doesn't exceed reservoir size
        num_exponents = min(num_exponents, Dr)
        print(f"Calculating {num_exponents} Lyapunov exponents for a {Dr}-dimensional system")
        
        # Initialize perturbation vectors (orthonormal basis)
        Q = np.eye(Dr, num_exponents)
        print(f"Initialized perturbation vectors Q with shape {Q.shape}")
        
        # Storage for Lyapunov exponents
        lyap_exp = np.zeros(num_exponents)
        
        # Get last state from transient period as initial state
        initial_state = self.generated_states[transient_steps] if transient_steps < len(self.generated_states) else self.generated_states[-1]
        
        # Run the system with perturbation vectors
        r = initial_state.copy()
        
        # Number of QR decompositions to perform
        num_iterations = (len(self.generated_states) - transient_steps) // orthonormalization_interval
        print(f"Will perform {num_iterations} QR decompositions")
        
        for i in range(num_iterations):
            if i > 0 and i % 10 == 0:
                print(f"Completed {i}/{num_iterations} iterations ({i/num_iterations*100:.1f}%)")
                
            # Evolve the system and perturbation vectors for orthonormalization_interval steps
            for j in range(orthonormalization_interval):
                # Calculate Jacobian at the current state
                J = self._calculate_jacobian(r)
                
                # Apply the Jacobian to each perturbation vector
                Q = np.dot(J, Q)
                
                # Get the next state from the stored states
                idx = transient_steps + i * orthonormalization_interval + j + 1
                if idx < len(self.generated_states):
                    r = self.generated_states[idx]
                else:
                    break
            
            # Perform QR decomposition
            Q, R = np.linalg.qr(Q)
            
            # Update Lyapunov exponents with the logarithm of the diagonal of R
            diag_R = np.diag(R)
            if len(diag_R) != num_exponents:
                print(f"Warning: R diagonal has shape {diag_R.shape}, expected {num_exponents}")
                # Ensure we only take the first num_exponents elements
                diag_R = diag_R[:num_exponents]
            
            lyap_exp += np.log(np.abs(diag_R))
        
        # Normalize by the number of iterations and the time step
        if num_iterations > 0:
            lyap_exp /= (num_iterations * orthonormalization_interval)
        
        print(f"Final Lyapunov exponents: {lyap_exp}")
        
        # Create plots if requested
        if plot:
            self._plot_lyapunov_spectrum(lyap_exp, save_dir)
        
        return lyap_exp
    
    def _calculate_jacobian(self, r):
        """
        Calculate the Jacobian matrix of the autonomous system at state r.
        
        Args:
            r: Reservoir state
            
        Returns:
            Jacobian matrix
        """
        Dr = self.Win.shape[0]
        D = self.Wout.shape[0]
        
        # Compute the Jacobian for the reservoir update in autonomous mode
        # J = d/dr [tanh(A*r + Win*Wout*r)]
        
        # First compute inner product A*r + Win*Wout*r
        if isinstance(self.A, np.ndarray):
            Ar = np.dot(self.A, r)
        else:  # sparse matrix
            Ar = self.A.dot(r)
            
        WinWout_r = np.dot(self.Win, np.dot(self.Wout, r))
        
        # Compute derivative of tanh
        inner = Ar + WinWout_r
        dtanh = 1.0 - np.tanh(inner)**2  # element-wise derivative of tanh
        
        # Compute derivative of the nonlinear part: d/dr [A*r + Win*Wout*r]
        if isinstance(self.A, np.ndarray):
            dF = self.A + np.dot(self.Win, self.Wout)
        else:  # sparse matrix
            dF = self.A.toarray() + np.dot(self.Win, self.Wout)
        
        # Apply chain rule: dtanh * dF
        J = np.zeros((Dr, Dr))
        for i in range(Dr):
            J[i] = dtanh[i] * dF[i]
        
        return J
    
    def _calculate_histogram_distances(self, bins=50):
        """
        Calculate distances between histograms of original and generated data.
        
        Args:
            bins: Number of bins for histograms
            
        Returns:
            Array of distances for each dimension
        """
        D = self.original_data.shape[1]
        distances = np.zeros(D)
        
        for d in range(D):
            # Compute histograms
            orig_hist, bin_edges = np.histogram(self.original_data[:, d], bins=bins, density=True)
            gen_hist, _ = np.histogram(self.generated_data[:, d], bins=bin_edges, density=True)
            
            # Compute L2 distance
            distances[d] = np.sqrt(np.sum((orig_hist - gen_hist)**2))
        
        return distances
    
    def _calculate_power_spectra_distances(self, nperseg=256):
        """
        Calculate distances between power spectra of original and generated data.
        
        Args:
            nperseg: Length of each segment for Welch method
            
        Returns:
            Array of distances for each dimension
        """
        D = self.original_data.shape[1]
        distances = np.zeros(D)
        
        for d in range(D):
            # Compute power spectra
            f_orig, Pxx_orig = signal.welch(self.original_data[:, d], nperseg=nperseg)
            f_gen, Pxx_gen = signal.welch(self.generated_data[:, d], nperseg=nperseg)
            
            # Compute L2 distance
            distances[d] = np.sqrt(np.sum((Pxx_orig - Pxx_gen)**2))
        
        return distances
    
    def _plot_short_term_prediction(self, length, save_dir=None):
        """
        Plot short-term prediction comparison.
        
        Args:
            length: Number of time steps to plot
            save_dir: Directory to save the plot
        """
        D = self.original_data.shape[1]
        n_rows = int(np.ceil(D / 2))
        
        plt.figure(figsize=(12, 3 * n_rows))
        
        for d in range(D):
            plt.subplot(n_rows, 2, d + 1)
            plt.plot(self.original_data[:length, d], 'b-', label='Original')
            plt.plot(self.generated_data[:length, d], 'r-', label='Prediction')
            plt.title(f'Dimension {d+1}')
            plt.legend()
        
        plt.tight_layout()
        
        if save_dir:
            plt.savefig(os.path.join(save_dir, 'short_term_prediction.png'), dpi=300)
            plt.close()
        else:
            plt.show()
    
    def _plot_attractors(self, save_dir=None):
        """
        Plot attractors from original and generated data.
        
        Args:
            save_dir: Directory to save the plot
        """
        D = self.original_data.shape[1]
        
        # Only plot for 2D or 3D data
        if D < 2:
            return
            
        if D == 2:
            # 2D attractor
            plt.figure(figsize=(12, 6))
            
            plt.subplot(1, 2, 1)
            plt.plot(self.original_data[:, 0], self.original_data[:, 1], 'b.', alpha=0.1)
            plt.title('Original Attractor')
            plt.xlabel('Dimension 1')
            plt.ylabel('Dimension 2')
            
            plt.subplot(1, 2, 2)
            plt.plot(self.generated_data[:, 0], self.generated_data[:, 1], 'r.', alpha=0.1)
            plt.title('Generated Attractor')
            plt.xlabel('Dimension 1')
            plt.ylabel('Dimension 2')
            
            plt.tight_layout()
            
            if save_dir:
                plt.savefig(os.path.join(save_dir, 'attractor_2d.png'), dpi=300)
                plt.close()
            else:
                plt.show()
                
        elif D >= 3:
            # 3D attractor using first 3 dimensions
            from mpl_toolkits.mplot3d import Axes3D
            
            fig = plt.figure(figsize=(12, 6))
            
            ax1 = fig.add_subplot(1, 2, 1, projection='3d')
            ax1.scatter(self.original_data[:, 0], self.original_data[:, 1], self.original_data[:, 2], 
                       c='b', marker='.', alpha=0.1)
            ax1.set_title('Original Attractor')
            ax1.set_xlabel('Dimension 1')
            ax1.set_ylabel('Dimension 2')
            ax1.set_zlabel('Dimension 3')
            
            ax2 = fig.add_subplot(1, 2, 2, projection='3d')
            ax2.scatter(self.generated_data[:, 0], self.generated_data[:, 1], self.generated_data[:, 2], 
                       c='r', marker='.', alpha=0.1)
            ax2.set_title('Generated Attractor')
            ax2.set_xlabel('Dimension 1')
            ax2.set_ylabel('Dimension 2')
            ax2.set_zlabel('Dimension 3')
            
            plt.tight_layout()
            
            if save_dir:
                plt.savefig(os.path.join(save_dir, 'attractor_3d.png'), dpi=300)
                plt.close()
            else:
                plt.show()
    
    def _plot_return_maps(self, save_dir=None):
        """
        Plot return maps (X_t vs X_{t+lag}) for the first dimension.
        
        Args:
            save_dir: Directory to save the plot
        """
        lag = 1
        
        plt.figure(figsize=(12, 6))
        
        plt.subplot(1, 2, 1)
        plt.plot(self.original_data[:-lag, 0], self.original_data[lag:, 0], 'b.', alpha=0.1)
        plt.title('Original Return Map')
        plt.xlabel('X(t)')
        plt.ylabel('X(t+1)')
        
        plt.subplot(1, 2, 2)
        plt.plot(self.generated_data[:-lag, 0], self.generated_data[lag:, 0], 'r.', alpha=0.1)
        plt.title('Generated Return Map')
        plt.xlabel('X(t)')
        plt.ylabel('X(t+1)')
        
        plt.tight_layout()
        
        if save_dir:
            plt.savefig(os.path.join(save_dir, 'return_maps.png'), dpi=300)
            plt.close()
        else:
            plt.show()
    
    def _plot_power_spectra(self, save_dir=None):
        """
        Plot power spectra for each dimension.
        
        Args:
            save_dir: Directory to save the plot
        """
        D = self.original_data.shape[1]
        n_rows = int(np.ceil(D / 2))
        
        plt.figure(figsize=(12, 3 * n_rows))
        
        for d in range(D):
            plt.subplot(n_rows, 2, d + 1)
            
            # Compute power spectra
            f_orig, Pxx_orig = signal.welch(self.original_data[:, d])
            f_gen, Pxx_gen = signal.welch(self.generated_data[:, d])
            
            plt.semilogy(f_orig, Pxx_orig, 'b-', label='Original')
            plt.semilogy(f_gen, Pxx_gen, 'r-', label='Generated')
            plt.title(f'Power Spectrum - Dimension {d+1}')
            plt.xlabel('Frequency')
            plt.ylabel('Power Spectral Density')
            plt.legend()
        
        plt.tight_layout()
        
        if save_dir:
            plt.savefig(os.path.join(save_dir, 'power_spectra.png'), dpi=300)
            plt.close()
        else:
            plt.show()
    
    def _plot_lyapunov_spectrum(self, lyap_exp, save_dir=None):
        """
        Plot Lyapunov spectrum.
        
        Args:
            lyap_exp: Array of Lyapunov exponents
            save_dir: Directory to save the plot
        """
        plt.figure(figsize=(10, 6))
        
        plt.plot(np.arange(1, len(lyap_exp) + 1), lyap_exp, 'bo-')
        plt.axhline(y=0, color='r', linestyle='--')
        
        plt.title('Lyapunov Spectrum')
        plt.xlabel('Exponent Index')
        plt.ylabel('Lyapunov Exponent')
        plt.grid(True)
        
        if save_dir:
            plt.savefig(os.path.join(save_dir, 'lyapunov_spectrum.png'), dpi=300)
            plt.close()
        else:
            plt.show() 